package edu.java.inheritance02;

public class InheritanceMain02 {

	public static void main(String[] args) {
		// 상속 관계에서 생성자 호출 순서:
		BusinessPerson p1 = new BusinessPerson(); // 사람 먼저, BP 나중
		BusinessPerson p2 = new BusinessPerson("아이티윌");
//		객체를 생성하면 heap 영역에 만들어진다. 클래스에 설계된 필드가 heap 영역의 메모리에 저장되는 것.
//		BP 호출 시 자바는 BP가 상속받는 person 클래스를 먼저 살펴보고
//		기본생성자의 역할: 클래스의 필드(name)를 기본값(null)으로 채운다. (확장) 
//		그 후 BP를 만들어야지. BP의 필드인 company 변수가 아이티윌로 채워진다.
//		그렇게 두개의 변수를 가지고 있는 것. 	
//		이 전체를 하나로 묶어주고.  그 주소를 p2 지역변수가 저장하는 것
		
		BusinessPerson p3 = new BusinessPerson("오쌤", "아이티윌");
		
		
		/* 하위 클래스의 객체를 생성하기 위해서 생성자를 호출하면 
		 * 항상 상위 클래스의 생성자가 먼저 실행되고, 그 후에 하위 클래스의 생성자가 실행됨.
		 * 하위 클래스의 생성자에서 상위 클래스의 생성자를 호출하려면 super(...)를 사용하면 됨 .. 조상님
		 * 하위 클래스의 생성자에서 상위 클래스의 생성자를 명시적으로 호출하지 않으면, 
		 * 상위클래스의 "기본 생성자(default constructor - argument x)"가 암묵적으로 호출됨
		 * 만약 상위 클래스에 기본 생성자가 없으면, (일부러 없앤거 기억! 자동호출x)
		 * 하위 클래스에서는 상위 클래스의 다른 생성자를 "반드시" 명시적으로 호출해야함 -public Person(String name)다른생성자 
		 * 
		 * <잡지식>
		 * 
		 * - 모든 클래스는 반드시 생성자를 가져야한다. 
		 * - 생성자: 인스턴스가 생성될 때마다 호출되는 인스턴스(객체 = iv묶음) 초기화 메서드
		 * 
		 * -자손의 변경은 조상에 영향을 미치지 않는다. 
		 * - 기존의 클래스로 새로운 클래스를 작성하는 것(코드의 재사용)
		 * - 두 클래스를 부모와 자식으로 관계를 맺어주는 것. 
		 * 모든 생성자는 첫줄에 다른 생성자를 호출(부모가 전부 있음.)
		 * 기본 생성자 작성 필수 (하트 두개 !!!!!!!!다시 듣기 super 도표 2개 이해, 정리못함. )
		 * 상속, 오브젝트 클래스, 포함까지 정리완료. 
		 * 
		 * static 메서드끼리 호출 가능. instance 메서드끼리 호출가능
		 * static 메서드에서  instance 멤버(메서드, 변수) 사용하려면 객체생성 필수
		 *  <stiatic>
		 * -  멤버변수 중 공통속성에 static을 붙임                  - 필드 : 공통속성 ?
		 * - iv, im을 사용하지 않는 메서드에 static을 붙인다.  - 메서드: iv 노사용 >객체 생성없이 바로 사용 가능한 메서드
		 * - 메서드: 명령문 집합 
		 * 메서드와 인스턴스 메서드 초록노랑이 부터 정리..!!!!!!!
		 * 
		 * 
		 * this의 의미 :
		 * 1. 생성된 (자기자신) 객체의 주소 : this.field, this.method()         . = 객체
		 * - 인스턴스 메서드(생성자 포함)에서 사용가능
		 * -모든 인스턴스메서드에서 지역변수로 숨겨진 채로 존재한다.
		 * - 진짜이름 : this.a  this.b   (참조변수.변수이름)
		 *-  같은 클래스 내에서 생략가능. 
		 * 
		 * 2. 같은 클래스에서 오버로딩된 다른 생성자 호출 : this(); this(...)     () = 생성자
		 * - 생성자에서 다른 생성자 호출할 때 사용
		 * - 클래스 이름대신 this 쓰는것
		 * 
		 *  -> 클래스 메서드: iv 사용불가, this(객체 자신) 사용불가
		 * 
		 * super의 의미:  생성된 부모타입의 객체
		 * 1. 생성된 상위 클래스의 객체의 주소 : super.field, super.method()
		 * - 참조변수
		 * - 인스턴스 메서드(생성자) 내에서만 존재(static 메서드 내에서 사용 불가)
		 * 
		 * 2. 상위 클래스의 생성자 : super(), super(...)
		 * - 조상의 생성자를 호출해서 자신의 멤버를 초기화 
		 * 
		 * 
		 * 지역변수(lv)는 수동초기화 해야함 - 우리가 직접 초기화
		 * 멤버변수 (iv, cv)는 자동 초기화 된다.
		 * 
		 * 참조형 변수 >> null : 기본값 / 객체 주소를 가짐
		 * engine e ; <- 참조가 끊어진 상태. 선언만 하고 (객체가 생성되지 않은 상태)  ㅁ안의 null(주소값이 null)
		 * 
		 * cv, iv 초기화: 자동초기화(기본값), 간단초기화(=) , 복잡초기화 -( iv: 생성자, cv : static{})
		 * <초기화 시점>
		 * cv : 클래스가 처음 로딩될 때 단 한번 (메모리에 올라갈 때)
		 * iv : 인스턴스 생성될 때마다 
		 * 순서 : ( cv -> lv)             (자동 , 간단, 복잡)
		 * 
		 *object 클래스 - 모든 클래스의 최고 조상
		 *조상이 없는 클래스는 자동적으로 object 클래스를 상속받게 된다. 
		 *모든 클래스는 object 클래스에 정의된 11개의 메서드를 상속받는다
		 *java는 단일상속만을 허용함 (c++은 다중상속)
		 *
		 * 클래스의 관계 1. 포함  2. 상속
		 * 상속: A는 B이다(is)
		 * 포함: A는 B를 가지고 있다(has)  ex) score
		 * - 클래스의 멤버로 참조변수를 선언하는 것.
		 * - 작은 단위의 클래스를 만들고, 이 둘을 조합해서 클래스를 만든다. 
		 * 
		 *오버로딩: 한 클래스 안에 같은 이름의 메서드/생성자를 여러개 정의하는 것
		 * 매개변수(parameter)는 다르지만 ->구별돼야 어떤 걸 호출하는 지 알 수 있음. 
		 * 같은 의미의 기능 수행
		 *- 메서드 이름이 같다 = 하는 작업이 같다
		 * ex) + : 부호, 덧셈, 문자열 결합
		 * 
		 * 오버로딩의 성립 조건
		 * 
		 * 1. 메서드 이름이 같아야 함
		 * 2. 매개변수의 개수 또는 타입이 달라야 함.
		 * 3. 반환타입은 영향 없음
		 * 
		 * final<><><><><<><><><><><><><><><><><><><><><><><><><><>
		 * 
		 * 추상클래스: 미완성 설계도 제품 생성 불가 객체 생성 불가
		 * 추상메서드: 몸통 없음. 미완성 메서드. 선언부만 있음. 클래스도 미완성 설계도가 됨. 둘다 abstract 붙여줘야
		 * 클래스를 사용하려면 상속을 통해서 추상메서드를 완성해줘야함. 몸통을 만들어줘야 쓸 수 있음. 
		 * 미완성 설계도라 제품 만들 수 없음.
		 * 추상메서드를 상속 받아서 완전한 클래스(설계도)를 만든 후에야 객체 생성 가능. <-> 구상클래스
		 * 구상클래스: 상속을 통해서 완성된 설계도 -> 객체 생성 가능
		 * 
		 * default : 다른 패키지의 자손도 포함함. 
		 * 클래스 앞 접근 제어자: default (package), public 두가지, 멤버(필드, 생성자, 메서드) - 4가지 모두 가능
		 * 
		 * Myparent class(main 메서드)에서 접근! - 객체 생성 
		 * 하나의 소스 파일에서는 public 클래스가 하나여야함.  & 소스파일 이름과 일치되어야 함.
		 * 클래스 앞에 public이 없으면 접근제어자가 packate(default)가 되는 것
		 * import: 클래스 이름 앞에 패키지 이름 쓰기 싫어서 하는 것
		 * class Mychild extends pkg1.Myparent
		 * pkg2.MyParentTest: 자손이면 괜찮은데 완전히 다른패키지의 완전히 다른 클래스(main)-> private, package, protected 전부 에러
		 * public만 됨.  <- 접근제한 없으니깐. 
		 * 
		 *  
		 * object 클래스: 모든 자바 클래스의 부모 클래스. - java.lang.Object
		 * super()생략됨 부모클래스인 tv에서 가져옴 ??
		 * string : 상속해서 접근 불가 스트링 보안
		 * math: static 메서드의 집합 <-굳이 상속받아 쓸 필요없음
		 * 
		 * Static : 객체 생성 없이 사용 가능.
		 * 멤버변수
		 * - 모든 인스턴스에 공통적으로 사용되는 클래스변수
		 * - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능
		 * - 클래스가 메모리에 로드될 때 생성된다.
		 * 
		 *  메서드 - iv, im 사용 x 
		 *  인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
		 *  static 메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다. 
		 *  
		 *  final
		 *  클래스: 변경될 수 없는 클래스. 확장될 수 없는 클래스가 됨
		 *  final로 지정된 클래스는 다른 클래스의 조상이 될 수 없음
		 *  
		 *  메서드: 변경할 수 없는메서드,  final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다. 
		 *  멤버변수, 지역변수 : 변수 아에 final이 붙으면 값을 변경할 수 없는 상수가 된다.
		 *  
		 *  abstract : 추상의 미완성의
		 *  클래스 - 클래스 내에 추상메서드가 선언되어 있음을 의미함 (추상 메서드를 포함한 클래스)
		 *  메서드 - 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알림(구현부가 없는 메서드)
		 *  AbstractTest a = new AbstractTest(); - 추상클래스의 인스턴스 : 생성불가
		 *  
		 *  제어자: 클래스와 클래스 멤버(멤버변수, 메서드, 생성자)에 부가적인 의미 부여
		 *  접근 제어자: public, protected, package(default), private
		 *  그 외: static, final, abstract,...
		 *  하나의 대상에 여러 제어자를 같이 사용 가능(접근 제어자는 하나만, 제일 왼쪽에)
		 *  
		 *  getter 메서드에서 return 값이 두개 이상일 수 있는가?
		 *  일반적으로 한번에 하나의 값을 반환하는 것이 좋음. 특정 상황에선 두개 이상의 값을 반환해야 하는데
		 *  자바에서는 메서드에서 한번에 하나의 값만 반환가능. 객체(Object)를 반환하는 건 가능.
		 *  객체는 반환하면 여러 값을 반환하는 것과 같은 효과를 가질 수 있음
		 *  다시 물어보기 자바 getter메서드에서 return 값이 두개 이상일 수 있어? 있다면 예제를 보여줘
		 *  
		 */
		
		
		
	}

}
