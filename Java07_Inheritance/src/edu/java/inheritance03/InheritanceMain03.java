package edu.java.inheritance03;

public class InheritanceMain03 {

	public static void main(String[] args) {
		// Car 타입의 객체 생성

		Car car1 = new Car(100, 30); // parameter로 넘어가는 순간 묵시적 자동 형변환 됨 -> argument에 넣는 값이 더 작아서 ㄱㅊ! 신경 ㄴㄴ
		car1.drive();

		HybridCar car2 = new HybridCar(90, 50, 100 ); 
		car2.drive();  // drive(), drive(int x) - 오버로딩!
		// 하이브리드를 하이브리드라 부름(너무나도 당연!)
		
		
		// 2. 
		//다형성(polymorphism) : 하나의 객체를 두개 이상의 타입으로 부를 수 있는 것.
		// 객체를 자기 자신 타입 뿐만 아니라 그 "상위" 타입의 변수에도 할당할 수 있는 것. (하위x)
		// 하이브리드 자동차는 "하이브리드 자동차"다.
		// 하이브리드 자동차는 "자동차"이다.
		// "" : 타입 . 타입으로 부름
		Car car3 = new HybridCar(100, 50, 100);
		// 하이브리드 객체를 자동차라 부르는 것!
		
		car3.drive();  // -> 3. 다형성이 적용된 경우에도, override 되어있는 메서드가 실행됨. 
	
		// 다형선은 코드의 재사용성(reuse)을 높여줌
		// 변수 선언, 배열/리스트 선언, 파라미터 선언 , 메서드 리턴 타입 선언, ...<- 사실은 변수 선언 말 한마디에 다 들어가있음.
		// SuperType (변수 선언: 항상 상위 타입으로, 객체 생성: 상위나 서브로 생성해서 변수에 할당할 수 있다. )
		
		
		Car[] cars = {car1, car2, car3}; 
		/* 4.
		* 자동차의 배열들 -> 자동차의 객체를 넣으면 됨. 하이브리드도 저장할 수 있음.
		* 다형성 제공되지 않았다면, 자동차 저장 배열과 하이브리드 저장 배열을 따로 만들어야 했을 것(코드 반복)
		* 자동차 배열이라 하면 자동차 뿐만 아니라 하위 개념들도 저장할 수 있는 것(코드의 재사용성)
		* 배열의 장점: 반복문을 써서 변수가 가진 객체를 호출하는 것 
		* 전부 다 drive(오버라이드 된 메서드)를 가지고 있음-> drive 메서드를 for문을 통해서 호출할 수 있는 것
		*/
		
	      //SuperType var = new SuperType();
	      //SuperType var = new SubType();
	      //SuperType[] arr = {new SuperType(), new SubType()};
	      //Car[] cars = new HybridCar[3]
		
		for(Car c : cars) {
			c.drive();
		}
		
		/* 5.
		* 다형성을 사용해서 정의된 메서드
		*System.out.println(Object x); , 나머지는 전부 오버로딩! 
		* 어떤 타입의 객체도 모두 argument 로 전달할 수 있음(argument가 Object 타입)
		* 자동차는 오브젝트다. 하이브리드는 오브젝트다. 둘다 넣어도 됨. 
		* jdk가 만들어졌을 땐 jdk 안에 자동차 클래스엔 없었을 것. 다형성이 없었으면 안 됬겠다.  
		* 개발자가 자신의 클래스를 설계할 때마다 자신의 println을 계속 만들어줘야 했을 것. 
		* jdk에는 object를 argument로 받는 println 메서드가 딱 하나 있는 것.
		* 하나를 만들어두면 어떤 클래스 타입의 객체든 간 argument로 넣어주면 되는 거고
		* println 메서드는 클래스 이름과 객체의 주소값을 프린트하도록 똑같은 기능을 함.
		* 모든 타입의 argument를 전달 받을 수 있다 -> 재사용성 높아진다. 
		* 오버라이드: 하위클래스에서만 존재한다. 
		*/
		
		System.out.println(car1); // 주소값 출력
		System.out.println(car2);
		System.out.println(car3);
		
		
		/* 3.
		 * 아무리 내가 car3을 car라고 부르더라도 얘의 본질(하이브리드)이 바뀌는 것x. 
		* 기능도 변하지 않음. 덮어써 버린 기능이라면(오버라이드 했다면) 그 기능이 호출된다. 
		* 다형성에서 실제로 실행되는 메서드: 하위클래스가 가지고 있는 메서드(오버라이드된 메서드)
		* 오버라이드 메서드가 있으면 오버라이드 된 메서드가 호출된다!
		* 생성된 객체를 super 타입, 자기자신 타입으로 부를 수 있는것 
		* sub 타입의 객체를 생성해서 super 타입을 할당하더라도. 객체의 실체가 바뀌지 않기에.
		*/
		
		/* 1.
		*  =     <- 하이브리드 자동차는 자동차다! (=> 하이브리드 객체를 자동차에 저장 가능한 것)
		*실제 만들어진 객체는 하이브리드지만 얘를 가리키면서 자동차입니다 라고 하는 것은 맞는얘기
		* 다형성: 객체는 하난데 그 객체를 여러가지 타입으로 부를 수 있는 것
		* 하이브리드 타입도, 자동차 타입이라 부를 수 있음
		* 실제로 만들어진 객체는 new smart tv.  가리키고 있는 변수는 tv
		* 한가지 객체를 두개 이상의 타입으로 부를  수 있다! 다형성 
		*super 타입은 안 됨!
		* 
		*/
	}
}  